---
title: "Comparing with mean (with signal) Discard a different column"
author: "Yuxin Zou"
date: 2018-04-25
output: 
  html_document:
    code_folding: hide
---
```{r read-chunk, include=FALSE, cache=FALSE}
knitr::read_chunk("chunks.R")
```

<!-- Update knitr chunk options -->
```{r knitr-opts-chunk, include=FALSE}
```

<!-- Insert the date the file was last updated -->
```{r last-updated, echo=FALSE, results='asis'}
```

<!-- Insert the R version (Git commit SHA1) if Git repository exists and R
 package git2r is installed -->
```{r R-version, echo=FALSE, results='asis'}
```

```{r, echo=FALSE}
# TEMPORARY.
knitr::opts_chunk$set(eval = TRUE)
```

```{r functions}
library(mashr)
library(corrplot)
source('../code/MashSource.R')
source('../code/sim_mean_sig.R')
```

# Discard a different column

In [MeanSignal](MeanSignal.html), the data was generated with signals in the first c conditions ($c_{j,1}, \cdots, c_{j,c}$). The contrast matrix L used there discards the last condition. The deviations are $\hat{c}_{j,1} - \bar{\hat{c}_{j}}, \hat{c}_{j,2} - \bar{\hat{c}_{j}}, \cdots, \hat{c}_{j,R-1} - \bar{\hat{c}_{j}}$.

However, the contrast matrix L can discard any deviation from $\hat{c}_{j,1} - \bar{\hat{c}_{j}}, \cdots, \hat{c}_{j,R} - \bar{\hat{c}_{j}}$. Let's see whether the choice of the discarded deviation could influence the reuslt.

We run the same model with L that discard the first deviation.

# Mash contrast
```{r}
set.seed(1)
R = 10
C = 2
data = sim.mean.sig(nsamp=10000, ncond=C)
```

```{r}
L.1 = matrix(-1/R, R, R)
L.1[cbind(1:R,1:R)] = (R-1)/R
L.1 = L.1[2:R,]
row.names(L.1) = seq(2,R)
mash_data.1 = mash_set_data(Bhat=data$Chat, Shat=data$Shat)
mash_data_L.1 = mash_set_data_contrast(mash_data.1, L.1)
```

```{r}
U.c = cov_canonical(mash_data_L.1)

# data driven
# select max
m.1by1 = mash_1by1(mash_data_L.1, alpha=1)
strong = get_significant_results(m.1by1,0.05)
# center Z
mash_data_L.center.1 = mash_data_L.1
mash_data_L.center.1$Bhat = mash_data_L.1$Bhat/mash_data_L.1$Shat # obtain z
mash_data_L.center.1$Shat = matrix(1, nrow(mash_data_L.1$Bhat),ncol(mash_data_L.1$Bhat))
mash_data_L.center.1$Bhat = apply(mash_data_L.center.1$Bhat, 2, function(x) x - mean(x))
U.pca = cov_pca(mash_data_L.center.1,2,strong)
U.ed = cov_ed(mash_data_L.center.1, U.pca, strong)

mashcontrast.model.1 = mash(mash_data_L.1, c(U.c, U.ed), algorithm.version = 'R', verbose = FALSE)
```
Using `mashcommonbaseline` model, there are `r length(get_significant_results(mashcontrast.model.1))` discoveries. The covariance structure found here is:
```{r, echo=FALSE}
barplot(get_estimated_pi(mashcontrast.model.1),las = 2, cex.names = 0.7)
```
The correlation PCA 1 is:
```{r, echo=FALSE, fig.width=3, fig.height=3,fig.align='center'}
x           <- cov2cor(mashcontrast.model.1$fitted_g$Ulist[["ED_PCA_1"]])
x[x > 1]    <- 1
x[x < -1]   <- -1
colnames(x) <- colnames(get_lfsr(mashcontrast.model.1))
rownames(x) <- colnames(x)
corrplot.mixed(x,upper='color',cl.lim=c(-1,1), upper.col=colorRampPalette(rev(c("#D73027","#FC8D59","#FEE090","#FFFFBF",
                               "#E0F3F8","#91BFDB","#4575B4")))(40),
               title='PCA1',mar=c(0,0,1.5,0))
```

## Recover
```{r}
mashcontrast.model.full.1 = mashcontrast.model.1
mashcontrast.model.full.1$result = mash_compute_posterior_matrices(g = mashcontrast.model.1, data = mash_data_L.1, algorithm.version = 'R', recover=TRUE)
```

There are `r length(get_significant_results(mashcontrast.model.full.1))` discoveries.

```{r, echo=FALSE, fig.width=3, fig.height=3,fig.align='center'}
U = mashcontrast.model.full.1$fitted_g$Ulist[["ED_PCA_1"]]
U_rec = cbind(-rowSums(U), U)
U_rec = rbind(c(sum(U), -rowSums(U)), U_rec)
x           <- cov2cor(U_rec)
x[x > 1]    <- 1
x[x < -1]   <- -1
colnames(x) <- c('Discard', colnames(get_lfsr(mashcontrast.model.1)))
rownames(x) <- colnames(x)
corrplot.mixed(x,upper='color',cl.lim=c(-1,1), upper.col=colorRampPalette(rev(c("#D73027","#FC8D59","#FEE090","#FFFFBF",
                               "#E0F3F8","#91BFDB","#4575B4")))(40),
               title='PCA1',mar=c(0,0,1.5,0))
```

# Subtract mean directly

```{r}
Indep.data.1 = mash_set_data(Bhat = mash_data_L.1$Bhat,
                           Shat = matrix(sqrt(0.5-1/(R*2)), nrow(data$Chat), R-1))

Indep.model.1 = mash(Indep.data.1, c(U.c, U.ed), algorithm.version = 'R', verbose = FALSE)
```
For `mashIndep` model, there are `r length(get_significant_results(Indep.model.1))` discoveries, which is **less** than the `mashcommonbaseline` model. The covariance structure found here is:
```{r, echo=FALSE}
barplot(get_estimated_pi(Indep.model.1),las = 2, cex.names = 0.7)
```

The correlation for PCA2 and tPCA is:
```{r, echo=FALSE, fig.width=8, fig.height=3,fig.align='center'}
par(mfrow=c(1,2))
x           <- cov2cor(Indep.model.1$fitted_g$Ulist[["ED_PCA_2"]])
x[x > 1]    <- 1
x[x < -1]   <- -1
colnames(x) <- seq(2,10)
rownames(x) <- colnames(x)
corrplot.mixed(x,upper='color',cl.lim=c(-1,1), upper.col=colorRampPalette(rev(c("#D73027","#FC8D59","#FEE090","#FFFFBF",
                               "#E0F3F8","#91BFDB","#4575B4")))(40),
               title='PCA2',mar=c(0,0,1.5,0))

x           <- cov2cor(Indep.model.1$fitted_g$Ulist[["ED_tPCA"]])
x[x > 1]    <- 1
x[x < -1]   <- -1
colnames(x) <- seq(2,10)
rownames(x) <- colnames(x)
corrplot.mixed(x,upper='color',cl.lim=c(-1,1), upper.col=colorRampPalette(rev(c("#D73027","#FC8D59","#FEE090","#FFFFBF",
                               "#E0F3F8","#91BFDB","#4575B4")))(40),
               title='tPCA',mar=c(0,0,1.5,0))
par(mfrow=c(1,1))
```

## Recover
```{r}
Indep.model.full.1 = Indep.model.1
Indep.model.full.1$result = mash_compute_posterior_matrices(g = Indep.model.1, data = Indep.data.1, algorithm.version = 'R', recover=TRUE)
```

There are `r length(get_significant_results(Indep.model.full.1))` discoveries.

```{r, echo=FALSE, fig.width=8, fig.height=3,fig.align='center'}
par(mfrow=c(1,2))
U1 = Indep.model.full.1$fitted_g$Ulist[["ED_PCA_2"]]
U1_rec = cbind(-rowSums(U1), U1)
U1_rec = rbind(c(sum(U1), -rowSums(U1)), U1_rec)
x           <- cov2cor(U1_rec)
x[x > 1]    <- 1
x[x < -1]   <- -1
colnames(x) <- c('Discard', seq(2,10))
rownames(x) <- colnames(x)
corrplot.mixed(x,upper='color',cl.lim=c(-1,1), upper.col=colorRampPalette(rev(c("#D73027","#FC8D59","#FEE090","#FFFFBF",
                               "#E0F3F8","#91BFDB","#4575B4")))(40),
               title='PCA2',mar=c(0,0,1.5,0))

U2 = Indep.model.full.1$fitted_g$Ulist[["ED_tPCA"]]
U2_rec = cbind(-rowSums(U2), U2)
U2_rec = rbind(c(sum(U2), -rowSums(U2)), U2_rec)
x           <- cov2cor(U2_rec)
x[x > 1]    <- 1
x[x < -1]   <- -1
colnames(x) <- c('Discard', seq(2,10))
rownames(x) <- colnames(x)
corrplot.mixed(x,upper='color',cl.lim=c(-1,1), upper.col=colorRampPalette(rev(c("#D73027","#FC8D59","#FEE090","#FFFFBF",
                               "#E0F3F8","#91BFDB","#4575B4")))(40),
               title='tPCA',mar=c(0,0,1.5,0))
par(mfrow=c(1,1))
```

# Compare two models

The RRMSE plot:
```{r, echo=FALSE}
L = matrix(-1/R, R, R)
L[cbind(1:R,1:R)] = (R-1)/R
row.names(L) = paste0('condition_',1:10)
C = data$C %*% t(L)
Chat = data$Chat %*% t(L)
barplot(c(sqrt(mean((C - mashcontrast.model.full.1$result$PosteriorMean)^2)/mean((C - Chat)^2)), sqrt(mean((C - Indep.model.full.1$result$PosteriorMean)^2)/mean((C - Chat)^2))), ylim=c(0,0.4), names.arg = c('mashcontrast.full', 'indep.full'), ylab='RRMSE')
```

We check the False Positive Rate and True Positive Rate. 
$$FPR = \frac{|N\cap S|}{|N|} \quad TPR = \frac{|CS\cap S|}{|T|} $$

```{r, echo=FALSE}
CS_S = function(model, thresh=0.05, data){
  sig.index = model$result$lfsr <= thresh
  sum(sig.index * model$result$PosteriorMean * data > 0)
}

N_S = function(model, thresh=0.05, data){
  N.index = data == 0
  sig.index = model$result$lfsr <= thresh
  sum(sig.index * N.index)
}

C = data$C - rowMeans(data$C)
N = sum(C == 0)
Tr = nrow(C) * ncol(C) - N

thresh.seq = seq(0, 1, by=0.0005)[-1]
mashcontrast = matrix(0,length(thresh.seq), 2)
Indep = matrix(0,length(thresh.seq), 2)
colnames(mashcontrast) = c('TPR', 'FPR')
colnames(Indep) = c('TPR', 'FPR')
for(t in 1:length(thresh.seq)){
  
  mashcontrast[t,] = c(CS_S(mashcontrast.model.full.1, thresh.seq[t], C)/Tr, N_S(mashcontrast.model.full.1, thresh.seq[t],C)/N)
  
  Indep[t,] = c(CS_S(Indep.model.full.1, thresh.seq[t], C)/Tr,  N_S(Indep.model.full.1, thresh.seq[t],C)/N)
}
```

```{r, echo=FALSE}
{plot(mashcontrast[,'FPR'], mashcontrast[,'TPR'], col='red',type='l',xlab = 'FPR', ylab='TPR')
lines(Indep[,'FPR'], Indep[,'TPR'])
legend('bottomright', c('mashcommon', 'mashIndep'),col=c('red','black'),lty=c(1,1))}
```

Using this contrast L, the results from `mashcommonbaseline` is better than `mashIndep`.

**The choice of L could influence the result.**


# Session information

<!-- Insert the session information into the document -->
```{r session-info}
```
