---
title: "UKBioBank MASH"
author: "Yuxin Zou"
date: 2018-6-27
output: 
  html_document:
    code_folding: hide
---
```{r read-chunk, include=FALSE, cache=FALSE}
knitr::read_chunk("chunks.R")
```

<!-- Update knitr chunk options -->
```{r knitr-opts-chunk, include=FALSE}
```

<!-- Insert the date the file was last updated -->
```{r last-updated, echo=FALSE, results='asis'}
```

<!-- Insert the code version (Git commit SHA1) if Git repository exists and R
 package git2r is installed -->
```{r code-version, echo=FALSE, results='asis'}
```

```{r echo=FALSE}
library(flashr); library(mashr);library(mclust);library(plyr)
library(lattice);library(ggplot2);library(colorRamps)
```

UKBioBank Strong data
```{r}
data = readRDS('../data/UKBioBank/StrongData.rds')
```

Estimate se based on *p values*
```{r}
# Adjust p value == 0
data$p[data$p == 0] = 1e-323
```

Fit EZ model directly to the Z scores, with standard errors of the non-missing Z scores set to 1 and the missing ones set to 10^6.
```{r}
mash.data = mash_set_data(Bhat = data$beta, pval = data$p, alpha = 1)
Zhat = mash.data$Bhat; Shat = mash.data$Shat
missing = is.na(Zhat)
Shat[missing] = 10^6
Zhat[missing] = 0
data.EZ = mash_set_data(Zhat,Shat)
```

# Estimate Covariance

```{r}
# column center
Z.center = apply(Zhat, 2, function(x) x - mean(x))
```

## Flash on centered Z

$$
Z = LF' + E
$$
Z is an $n \times p$ observed centered data, F is a $p\times k$ matrix of factors, L is an $n \times k$ matrix of loadings.

Results from [Flash_UKBio](Flash_UKBio.html)
```{r}
fmodel = readRDS('../output/Flash_UKBio_strong.rds')
```

Suppose the rows of L come from a mixture of multivariate normals, with covariances $\Sigma_1,\dots,\Sigma_M$ (each one a K by K matrix).
$$
l_{i \cdot} \sim \sum_{j=1}^{M} N(\mu_{j}, \Sigma_{j})
$$
Then the rows of $LF'$ come from a mixture of multivariate normals 
$$
Fl_{i\cdot} \sim \sum_{j=1}^{M} N(F\mu_{j}, F\Sigma_{j}F')
$$
We estimate the covariance matrix as $F(\Sigma_{j}+\mu_{j}\mu_{j}')Fâ€²$.

Cluster loadings:
```{r}
loading = fmodel$EL[,1:18]
colnames(loading) = paste0('Factor',seq(1,18))
mod = Mclust(loading)
summary(mod$BIC)
```
```{r}
U_list = alply(mod$parameters$variance$sigma,3)
mu_list = alply(mod$parameters$mean,2)
ll = list()
for (i in 1:length(U_list)){
  ll[[i]] = U_list[[i]] + mu_list[[i]] %*% t(mu_list[[i]])
}

Factors = fmodel$EF[,1:18]
U.loading = lapply(ll, function(U){Factors %*% (U %*% t(Factors))})
names(U.loading) = paste0('Load', "_", (1:length(U.loading)))

# rank 1
Flash_res = flash_get_lf(fmodel)
U.Flash = c(mashr::cov_from_factors(t(as.matrix(Factors)), "Flash"), 
            list("tFlash" = t(Flash_res) %*% Flash_res / nrow(Z.center)))
```

## PCA
```{r}
U.pca = cov_pca(data.EZ, 5)
```

## Extreme Deconvolution

```{r, eval=FALSE}
U.dd = c(U.pca, U.loading, U.Flash, list('XX' = t(data.EZ$Bhat) %*% data.EZ$Bhat / nrow(data.EZ$Bhat)))

U.ed = cov_ed(data.EZ, U.dd)
saveRDS(U.ed, '../output/CovED_UKBio_strong_Z.rds')
```

```{r}
U.ed = readRDS('../output/CovED_UKBio_strong_Z.rds')
```

## Canonical
```{r}
U.c = cov_canonical(data.EZ)
```

# Mash model

Read random data
```{r}
data.rand = readRDS('../data/UKBioBank/RandomData.rds')
# Estimate se based on p values
# Adjust p value == 0
data.rand$p[data.rand$p == 0] = 1e-323
mash.data.rand = mash_set_data(Bhat = data.rand$beta, pval = data.rand$p, alpha = 1)
Zhat = mash.data.rand$Bhat; Shat = mash.data.rand$Shat
missing = is.na(Zhat)
Shat[missing] = 10^6
Zhat[missing] = 0
data.rand.EZ = mash_set_data(Zhat,Shat)
Vhat = estimate_null_correlation(data.rand.EZ)
```

```{r, eval=FALSE}
data.rand.EZ.V = mash_set_data(data.rand.EZ$Bhat, data.rand.EZ$Shat, V = Vhat)
mash.model = mash(data.rand.EZ.V, c(U.c, U.ed), outputlevel = 1)
saveRDS(mash.model, '../output/UKBio_mash_model.rds')
```

```{r}
mash.model = readRDS('../output/UKBio_mash_model.rds')
```

The log-likelihood of fit is
```{r} 
get_loglik(mash.model)
```

Here is a plot of weights learned:

```{r}
options(repr.plot.width=12, repr.plot.height=4)
barplot(get_estimated_pi(mash.model), las = 2, cex.names = 0.7)
```

`ED_XX`:
```{r}
x           <- cov2cor(mash.model$fitted_g$Ulist[["ED_XX"]])
x[x < 0]    <- 0
colnames(x) <- colnames(get_lfsr(mash.model))
rownames(x) <- colnames(x)
x <- x[rev(rownames(x)),rev(colnames(x))]
x[lower.tri(x)] <- NA
clrs <- colorRampPalette(rev(c("#D73027","#FC8D59","#FEE090","#FFFFBF",
                               "#E0F3F8","#91BFDB","#4575B4")))(64)
n <- nrow(x)
options(repr.plot.width=9, repr.plot.height=9)
print(levelplot(x[n:1,],col.regions = clrs,xlab = "",ylab = "",
                colorkey = TRUE, at = seq(0,1,length.out = 64),
                scales = list(cex = 0.5,x = list(rot = 45))))
```

The top eigenvalues:
```{r}
svd.out = svd(mash.model$fitted_g$Ulist[["ED_XX"]])
v = svd.out$v
colnames(v) = colnames(get_lfsr(mash.model))
rownames(v) = colnames(v)
options(repr.plot.width=10, repr.plot.height=5)
for (j in 1:6)
  barplot(v[,j]/v[,j][which.max(abs(v[,j]))], cex.names = 0.6,
          las = 2, main = paste0("EigenVector ", j, " for empirical covariance matrix"))
```

`ED_load_4`
```{r}
x           <- cov2cor(mash.model$fitted_g$Ulist[["ED_Load_4"]])
x[x < 0]    <- 0
colnames(x) <- colnames(get_lfsr(mash.model))
rownames(x) <- colnames(x)
x <- x[rev(rownames(x)),rev(colnames(x))]
x[lower.tri(x)] <- NA
clrs <- colorRampPalette(rev(c("#D73027","#FC8D59","#FEE090","#FFFFBF",
                               "#E0F3F8","#91BFDB","#4575B4")))(64)
n <- nrow(x)
options(repr.plot.width=9, repr.plot.height=9)
print(levelplot(x[n:1,],col.regions = clrs,xlab = "",ylab = "",
                colorkey = TRUE, at = seq(0,1,length.out = 64),
                scales = list(cex = 0.5,x = list(rot = 45))))
```

The top eigenvalues:
```{r}
svd.out = svd(mash.model$fitted_g$Ulist[["ED_Load_4"]])
v = svd.out$v
colnames(v) = colnames(get_lfsr(mash.model))
rownames(v) = colnames(v)
options(repr.plot.width=10, repr.plot.height=5)
for (j in 1:3)
  barplot(v[,j]/v[,j][which.max(abs(v[,j]))], cex.names = 0.6,
          las = 2, main = paste0("EigenVector ", j, " for Load 4 covariance matrix"))
```

# Posterior

```{r}
data.strong = mash_set_data(data.EZ$Bhat, data.EZ$Shat, V = Vhat)
mash.model$result = mash_compute_posterior_matrices(mash.model, data.strong)
```

There are `r length(get_significant_results(mash.model))` significant snps.

Pairwise sharing:

```{r}
x           <- get_pairwise_sharing(mash.model)
colnames(x) <- colnames(get_lfsr(mash.model))
rownames(x) <- colnames(x)
x <- x[rev(rownames(x)),rev(colnames(x))]
x[lower.tri(x)] <- NA
clrs <- colorRampPalette(rev(c("#D73027","#FC8D59","#FEE090","#FFFFBF",
                               "#E0F3F8","#91BFDB","#4575B4")))(64)
n <- nrow(x)
options(repr.plot.width=9, repr.plot.height=9)
print(levelplot(x[n:1,],col.regions = clrs,xlab = "",ylab = "",
                colorkey = TRUE, at = seq(0,1,length.out = 64),
                scales = list(cex = 0.5,x = list(rot = 45))))

```

# Session information

<!-- Insert the session information into the document -->
```{r session-info}
```

