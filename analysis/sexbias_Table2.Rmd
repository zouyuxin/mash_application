---
title: "Table 2"
author: "Yuxin Zou"
date: 2018-2-1
output: html_document
---
```{r read-chunk, include=FALSE, cache=FALSE}
knitr::read_chunk("chunks.R")
```

<!-- Update knitr chunk options -->
```{r knitr-opts-chunk, include=FALSE}
```

<!-- Insert the date the file was last updated -->
```{r last-updated, echo=FALSE, results='asis'}
```

<!-- Insert the code version (Git commit SHA1) if Git repository exists and R
 package git2r is installed -->
```{r code-version, echo=FALSE, results='asis'}
```

```{r, echo=FALSE}
# TEMPORARY.
knitr::opts_chunk$set(eval = TRUE)
```

```{r echo=FALSE}
library(gdata); library(mashr);library(flashr)
library(mclust); library(plyr); library(corrplot)
```

# Read Table 2
```{r, eval=FALSE, echo=FALSE}
SupplTable2 = read.xls('../data/Suppl.Table.2.xlsx')
saveRDS(SupplTable2, '../data/SupplTable2.rds')
```
```{r, echo=FALSE}
SupplTable2 = readRDS('../data/SupplTable2.rds')
```

There are missing value in the data. I guess this is caused by the 0 count, since the effect is $\log_{2} (X_{1}/X_{2})$. We set these NAs to 0 with huge variance.

```{r, eval=FALSE, echo=FALSE}
Genename = as.character(SupplTable2$Gene.ID)
colname = colnames(SupplTable2)[seq(3,89,by=3)]
Tissue = gsub( "_.*$", "",  colname)

p.value = SupplTable2[,seq(3,89,by=3)]
logFC = SupplTable2[,seq(4,89,by=3)]

missing = is.na(as.matrix(logFC))

p.value[is.na(as.matrix(p.value))] = 1
logFC[is.na(as.matrix(logFC))] = 0

row.names(p.value) = Genename
row.names(logFC) = Genename
colnames(p.value) = Tissue
colnames(logFC) = Tissue

saveRDS(list(logFC = as.matrix(logFC), pval = as.matrix(p.value), category = SupplTable2$category, region = SupplTable2$region, missing = missing), '../data/SupplTable2_0.rds')
```

```{r, echo=FALSE}
data = readRDS('../data/SupplTable2_0.rds')
```

Since the sample size is large, we assume the p value is from normal distribution.

```{r}
# some p values are exactly 1, z = 0, 
# make them a little smaller
data$pval[data$pval == 1] = 0.999999

mash.data = mash_set_data(Bhat = data$logFC, pval = data$pval)
# set large variance to missing data
mash.data$Shat[data$missing] = 1000

# find strong genes
m.1by1 = mash_1by1(mash.data, alpha=1)
strong = get_significant_results(m.1by1, 0.01)
# estimate cor V on non strong genes
Z = mash.data$Bhat/mash.data$Shat
Z.null = Z[setdiff(1:349,strong),]
```

# Estimate covariance structure using strong genes
```{r}
Z.strong = Z[strong,]
# center
Z.center = apply(Z.strong, 2, function(x) x - mean(x))
```

## Flash
$$ \tilde{Z} = LF' + E $$
where F is $29 \times K$, L is $n \times K$, E is $n\times 29$.
```{r, eval=FALSE}
K = 10
mash_data_flash = flash_set_data(as.matrix(Z.center))
f_greedy = flash_add_greedy(mash_data_flash, Kmax=K, var_type = 'by_column')

# Backfitting
f_greedy_bf = flash_backfit(mash_data_flash,f_greedy, var_type = 'by_column')
F_flash = flash_get_f(f_greedy_bf)
L_flash = flash_get_l(f_greedy_bf)

FlashResult = list(f_greedy = f_greedy,
             f = f_greedy_bf,
             F_flash = F_flash,
             L_flash = L_flash)
saveRDS(FlashResult, '../output/Flash_T2_0.rds')
```

### Flash result

```{r, echo=FALSE}
FlashResult = readRDS('../output/Flash_T2_0.rds')
```

The first factor explains the main proportion of variance in effects.
```{r}
flash_get_pve(FlashResult$f)
```

The first factor is the overall summary of treatment effects.
```{r, echo=FALSE}
row.names(FlashResult$F_flash) = colnames(data$logFC)
layout(matrix(c(1,2,3,4,5,6), 3, 2, byrow = TRUE))
barplot(FlashResult$F_flash[,1], las=2, main='Factor 1', cex.names = 0.7)
barplot(FlashResult$F_flash[,2], las=2, main='Factor 2', cex.names = 0.7)
barplot(FlashResult$F_flash[,3], las=2, main='Factor 3', cex.names = 0.7)
barplot(FlashResult$F_flash[,4], las=2, main='Factor 4', cex.names = 0.7)
barplot(FlashResult$F_flash[,5], las=2, main='Factor 5', cex.names = 0.7)
```

### Clustering loadings
```{r, eval=FALSE}
loading = FlashResult$L_flash[,1:5]
row.names(loading) = rownames(Z.strong)
colnames(loading) = paste0('F',seq(1,5))

mod = Mclust(loading)
summary(mod$BIC)
saveRDS(mod, '../output/Flash_T2_0_mclust.rds')
```
Using clustering result to fit `mash`:

$$l_{i}\sim \sum_{i=1}^{m}N(\mu_{i}, \Sigma_{i})$$
We estimate the covariance as $F(\Sigma_i + \mu_{i}\mu_{i}')F'$.
```{r, echo=FALSE}
mod = readRDS('../output/Flash_T2_0_mclust.rds')
```
```{r}
U_list = alply(mod$parameters$variance$sigma,3)
mu_list = alply(mod$parameters$mean,2)
Factors = FlashResult$F_flash[,1:5]
ll = list()
for (i in 1:length(U_list)){
  ll[[i]] = U_list[[i]] + mu_list[[i]] %*% t(mu_list[[i]])
}

U.loading = lapply(ll, function(U){Factors %*% (U %*% t(Factors))})
names(U.loading) = paste0('Load', "_", (1:length(U.loading)))

# rank 1

Flash_res = flash_get_lf(FlashResult$f)

U.Flash = c(mashr::cov_from_factors(t(as.matrix(FlashResult$F_flash[,1:5])), "Flash"), 
            list("tFlash" = t(Flash_res) %*% Flash_res / nrow(Z.center)))
```

## PCA
```{r}
U.pca = cov_pca(mash_set_data(Z.center), 8)
```

## Canonical
```{r}
U.c = cov_canonical(mash_set_data(Z.center))
```

## Extreme Deconvolution
```{r, eval=FALSE}
U.dd = c(U.pca, U.loading, U.Flash, list('XX' = t(Z.center) %*% Z.center / nrow(Z.center) ))

saveRDS(cov_ed(mash_set_data(Bhat = Z.strong), U.dd), '../output/Mash_EZ_Cov_0_plusR1.rds')
```

# mash model
```{r, echo=FALSE}
U.ed = readRDS('../output/Mash_EZ_Cov_0_plusR1.rds')
```

```{r}
vhat = 1

if (vhat == 1) {
  V = cor(Z.null)
} else {
  V = diag(ncol(Z.null))
}

mash_data = mash_set_data(Bhat = mash.data$Bhat, Shat = mash.data$Shat, V = V, alpha = 1)

saveRDS(mash(mash_data, c(U.c, U.ed)), '../output/Mash_model_0_plusR1.rds') 
```

# V1 EZ result

```{r echo=FALSE}
mash.model = readRDS('../output/Mash_model_0_plusR1.rds')
```

The log-likelihood of fit is
```{r} 
get_loglik(mash.model)
```
Here is a plot of weights learned.

```{r, echo=FALSE}
options(repr.plot.width=12, repr.plot.height=4)
barplot(get_estimated_pi(mash.model), las = 2, cex.names = 0.7)
```

Check `ED_XX` and `ED_tPCA`:
```{r, echo=FALSE}
layout(matrix(c(1,2,3,4), 2, 2, byrow=TRUE))
svd.out = svd(mash.model$fitted_g$Ulist[["ED_XX"]])
v = svd.out$v
colnames(v) = colnames(get_lfsr(mash.model))
rownames(v) = colnames(v)
options(repr.plot.width=10, repr.plot.height=5)
for (j in 1:1)
  barplot(v[,j]/v[,j][which.max(abs(v[,j]))], cex.names = 0.7,
          las = 2, main = paste0("EigenVector ", j, " for XX"))

svd.out = svd(mash.model$fitted_g$Ulist[["ED_tPCA"]])
v = svd.out$v
colnames(v) = colnames(get_lfsr(mash.model))
rownames(v) = colnames(v)
options(repr.plot.width=10, repr.plot.height=5)
for (j in 1:3)
  barplot(v[,j]/v[,j][which.max(abs(v[,j]))], cex.names = 0.7,
          las = 2, main = paste0("EigenVector ", j, " for tPCA"))
```

Among the 959 genes, `MASH` found `r length(get_significant_results(mash.model, 0.01))` to be significant in at least one treatment. The result is similar as condition by condition analysis.

```{r}
Missing.lfsr = mash.model$result$lfsr * data$missing
Missing.lfsr[Missing.lfsr == 0] = NA
sum(Missing.lfsr < 0.01, na.rm = TRUE)
```
```{r, echo=FALSE}
# which(Missing.lfsr < 0.01, arr.ind = TRUE)
```

Some effects are estimated as significant, even though they are originally missing!

For example, the original data is missing for gene `r as.character(SupplTable2$Gene.name[880])` at tissue `r colnames(data$logFC)[3]`. In the `mash.data`, it has Bhat = `r mash.data$Bhat[880,3]` with Shat = `mash.data$Shat[880,3]`. The posterior mean from the mash model is `r mash.model$result$PosteriorMean[880,3]` with sd `r mash.model$result$PosteriorSD[880,3]`.

```{r, echo=FALSE}
Escape.prop = numeric(29)
for(i in 1:29){
  Escape.prop[i] = length(which(data$category[get_significant_results(mash.model,0.01, conditions = i)] == 'Escape')) / length(which(data$category == 'Escape'))
}
Variable.prop = numeric(29)
for(i in 1:29){
  Variable.prop[i] = length(which(data$category[get_significant_results(mash.model,0.01, conditions = i)] == 'Variable')) / length(which(data$category == 'Variable'))
}
Inac.prop = numeric(29)
for(i in 1:29){
  Inac.prop[i] = length(which(data$category[get_significant_results(mash.model,0.01, conditions = i)] == 'Inactive')) / length(which(data$category == 'Inactive'))
}
Unknown.prop = numeric(29)
for(i in 1:29){
  Unknown.prop[i] = length(which(data$category[get_significant_results(mash.model,0.01, conditions = i)] == 'Unknown')) / length(which(data$category == 'Unknown'))
}

prop = c(Escape.prop, Variable.prop, Inac.prop, Unknown.prop)
group = rep(c('Escape', 'Variable', 'Inactive', 'Unknown'), each=29)
boxplot(prop~group, ylab='Sex-bias per tissue (% of genes)')
```

# Session information

<!-- Insert the session information into the document -->
```{r session-info}
```

